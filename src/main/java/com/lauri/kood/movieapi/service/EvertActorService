/*


@Service
@Transactional
@AllArgsConstructor
public class ActorService {
    private final ActorRepository actorRepository;
    private final MovieRepository movieRepository;

    private ActorResponseDto toActorResponseDto(Actor actor) {
        return new ActorResponseDto(actor.getId(), actor.getName(), actor.getBirthDate());
    }

    //Create
    public ActorResponseDto create(ActorPatchDto actorDto) {
        Actor actor = new Actor();
        actor.setName(actorDto.name());
        actor.setBirthDate(actorDto.birthDate());
        actorRepository.save(actor);
        return toActorResponseDto(actor);
    }

    // Retrieve all actors from the database
    public List<ActorResponseDto> getAll() {
        return actorRepository.findAll().stream().map
        (a -> new ActorResponseDto(a.getId(), a.getName(), a.getBirthDate())).toList();

    }

    // Retrieve a specific actor by ID
    public ActorResponseDto getById(Long id) {
        Actor actor = actorRepository.findById(id).orElseThrow(() ->
        new IllegalArgumentException("Actor with id " + id + " not found"));
        return toActorResponseDto(actor);
    }

    // Filter actors by name
    public List<ActorResponseDto> getName(String name) {
        return actorRepository.findByNameContainingIgnoreCase(name).stream()
                .map(this::toActorResponseDto)
                .toList();
    }

    // Retrieve movies actor has appeared in

    public Set<MovieFlatDto> getMovies(Long id) {
        // Fetch the  Actor entity from the database
        Actor actor = actorRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException
                ("Actor with id " + id + " not found"));

        // 2. Get the Set<Movie> from the entity and map it to a Set<MovieFlatDto>.
        return actor.getMovies().stream()
                .map(movie -> new MovieFlatDto
                (movie.getId(), movie.getTitle(), movie.getReleaseYear(), movie.getDuration()))
                .collect(Collectors.toSet());
    }

    // Modify actor's details
    public ActorResponseDto update(Long id, ActorPatchDto actorDto) {
        Actor currentActor = actorRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Actor with id " + id + " not found"));

        if (actorDto.name() != null) {
            currentActor.setName(actorDto.name());
        }
        if (actorDto.birthDate() != null) {
            currentActor.setBirthDate(actorDto.birthDate());
        }
        if (actorDto.removeMovieIds() != null) {
            for (Movie movie : currentActor.getMovies()) {
                if (actorDto.removeMovieIds().contains(movie.getId())) {
                    movie.getActors().remove(currentActor);
                }

            }

        }
        if (actorDto.addMovieIds() != null) {
            for (Movie movie : currentActor.getMovies()) {
                if (actorDto.addMovieIds().contains(movie.getId())) {
                    movie.getActors().add(currentActor);
                }

            }
        }
        Actor savedActor = actorRepository.save(currentActor);
        return toActorResponseDto(savedActor);
    }

    public void delete(Long id, boolean force) {
        Actor actor = actorRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Actor with id " + id + " not found"));

        // If force is false, checks for existing movie relationships
        if (!force && !actor.getMovies().isEmpty()) {
            // If movies are found, block the deletion and throw an error
            throw new IllegalStateException(
                    "Cannot delete actor '" + actor.getName() + "' as they are in " +
                            actor.getMovies().size() + " movies. Use 'force=true' to override."
            );
        }

        // If forcing, remove the actor from all associated movies
        for (Movie movie : actor.getMovies()) {
            movie.getActors().remove(actor);
        }

        actorRepository.delete(actor);
    }
}
 */